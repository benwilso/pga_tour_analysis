# -*- coding: utf-8 -*-
"""13-psklam-jado-benwilso-2025winter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UopYfGUwEb03BnEwlur2eTC-IIuVNGzk

## Section 1 - Data Import & Asset Creation

In this section we import our 2 datasets and merge them into a single asset. The first dataset - PGA Tour Data (2015 - 2022) includes tournament data (name, date, location), course data (name, par), and detailed player performance measures, including all strokes gained measures for each player in a given tournament. It covers all PGA tour events in the 2015 through 2022 seasons.

The second dataset - Official World Golf Ranking - includes weekly official world golf rankings of the top 300 players, from January 1, 1997 through February 21, 2021. It includes key variables including player name, player ranking, and date of the ranking.

The main output of Section 1 is a single dataframe combining both datasets called 'final_df'.
"""

# Include all imports here
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.patches import Wedge
import seaborn as sns

# Initialize some shared characteristics for all visualizations
plt.rcParams['figure.facecolor'] = '#076652' # Masters green
plt.rcParams['text.color'] = '#FFFFFF'

# Filepaths for source data files
path1 = 'Downloads/ASA All PGA Raw Data - Tourn Level.csv'
path2 = 'Downloads/OWGR Historical.csv'

"""These next 2 cells import the source files into pandas dataframes, and implement the primary data cleaning steps:"""

# Import dataset #1 & prepare for merge
df_main = pd.read_csv(path1)
df_main.columns = df_main.columns.str.lower()
df_main['player'] = df_main['player'].str.upper()
df_main['date'] = pd.to_datetime(df_main['date'])
df_main['year'] = df_main['date'].dt.year
df_main = df_main[df_main['year'].isin([2015, 2016, 2017, 2018, 2019])]

# Import dataset #2 & prepare for merge
df_owgr = pd.read_csv(path2, encoding= 'unicode_escape')
df_owgr = df_owgr[['Player', 'Date', 'OWGR']]
df_owgr['Date'] = pd.to_datetime(df_owgr['Date'])
df_owgr.columns = df_owgr.columns.str.lower()

"""This cell accomplishes a couple of key tasks:
- Created a properly formatted Year-Week field to eliminate date discrepancies between the two tables allowing for a seamless merge using .strftime().
- Left joined the primary dataset with the secondary dataset using .merge() with keys of Player Name and Year-Week.  A left join is used to ensure we didn’t drop any players with records in the primary dataset who were never seen in the secondary dataset.

This results in the combined asset 'final_df'.
"""

# Created a properly formatted Year-Week field to eliminate date discrepancies between the two tables
df_main['Year-Week'] = df_main['date'].dt.strftime('%Y-%U')
df_owgr['Year-Week'] = df_owgr['date'].dt.strftime('%Y-%U')

# Left joined the primary dataset with the secondary dataset using pd.merge() with keys of player and Year-Week
final_df = pd.merge(df_main, df_owgr, on=['player', 'Year-Week'], how='left')

"""This cell adds a couple of new features to the final dataframe:
- World Ranking Bin feature for every 10 places up to 300 (1-10, 11-20, etc.).
- Strokes to Par feature for each player in each tournament showing their individual tournament performance.

"""

# Feature Engineering - Create World Ranking Bin
final_df['rank_bucket'] = (final_df['owgr'] // 10) * 10

# Feature Engineering - Add field for strokes to par
final_df['strokes_to_par'] = final_df['strokes'] - final_df['hole_par']

# Feature Engineering - Create a Year-Week feature in both datasets
# ---> This step was completed above

# Feature Engineering - Add a field that is just the year in which a given entry occurred
# ---> This step was completed above

"""This cell implements additional data cleaning steps on the final combined dataset"""

# Data Cleaning of Combined Dataset - Remove players who have played in fewer than 10 tournaments
player_tournament_counts = final_df['player'].value_counts() # Count the number of tournaments each player has played
players_meeting_threshold = player_tournament_counts[player_tournament_counts >= 10].index
final_df = final_df[final_df['player'].isin(players_meeting_threshold)]

# Data Cleaning of Combined Dataset - Remove players who never appear in the top 300
players_main = df_main['player'].unique()
players_owgr = df_owgr['player'].unique()
players_not_in_owgr = set(players_main) - set(players_owgr)
final_df = final_df[~final_df['player'].isin(players_not_in_owgr)]

# Data Cleaning of Combined Dataset - Impute value of 301 for players who played tournaments outside the OWGR top 300
final_df['owgr'] =  final_df['owgr'].fillna(301)

# Test Cell for above
# Check minimum tournaments played (should be >= 10)
print(final_df['player'].value_counts().min())

"""## Section 2 - Data Preprocessing

In this section we perform some preprocessing on our finished asset and create some common outputs that will be used for several of our analytical & visualization tasks.

First, in order to identify the top players during the 2015 - 2019 period, the overall change in each player’s world golf ranking through this period was calculated. Players having achieved the greatest improvement in ranking are considered to be the top players during this period. To do this, the function below creates a new dataframe containing the best and worst rankings for each player, the date those rankings occurred, and the delta between the best and worst rankings. It then sorts the dataframe by this delta value, and returns lists of the the top and bottom 'num_players' from this dataframe.

"""

# This function will take the merged asset we created and return 3 things:
# 1) A dataframe showing each player's lowest & highest rankings through the period of inquiry, and the corresponding delta
# 2) A list of the players whose ranking improved the most (jumps)
# 3) A list of players whose ranking dropped the most (drops)
# num_players is the number of players to put in the jumps / drops lists

def find_biggest_movers(final_df, num_players):
    """
    This function identifies players who have seen the biggest increases and decreases in
    their OWGR ranking.

    Parameters:
    final_df: Pandas dataframe containing player names and OWGR ranking
    num_players: Integer indicating how many players to in clude in returned lists.

    Returns:
    Tuple consisting of:
    - player_stats_final: Pandas dataframe with overall change in ranking for each player in the input dataframe
    - jumps: List of length num_players showing players with the greatest increase in OWGR ranking
    - drops: List of length num_players showing players with the greatest decrease in OWGR ranking
    """

    # Step 1 - Groupby 'Player' and calculate the highest and lowest OWGR and their corresponding dates
    player_stats = (
        final_df.drop(columns='player')  # Exclude the grouping column from processing
        .groupby(final_df['player'], group_keys=False)  # Group using the original Player column
        .apply(lambda group: pd.Series({
            'Lowest OWGR Ranking': group['owgr'].max(),
            'Date of Lowest OWGR Ranking': group.loc[group['owgr'].idxmax(), 'date_x'],
            'Highest OWGR Ranking': group['owgr'].min(),
            'Date of Highest OWGR Ranking': group.loc[group['owgr'].idxmin(), 'date_x'],
        }))
        .reset_index()  # Restore 'Player' as a column in the final dataframe
    )

    # Step 2 - Find the delta between lowest and highest rankings
    for index, row in player_stats.iterrows():
        difference = row['Date of Lowest OWGR Ranking'] < row['Date of Highest OWGR Ranking']
        if difference == True:
            player_stats.at[index, 'Delta'] = row['Lowest OWGR Ranking'] - row['Highest OWGR Ranking']
        else:
            player_stats.at[index, 'Delta'] = -1*(row['Lowest OWGR Ranking'] - row['Highest OWGR Ranking'])

    # Step 3 - Sort the dataframe based on delta
    player_stats_final = player_stats.sort_values('Delta', ascending = False)

    # Step 4 - Create the lists of jumps & drops
    jumps = player_stats_final.iloc[:num_players, player_stats_final.columns.get_loc('player')].to_list()
    drops = player_stats_final.iloc[-num_players:, player_stats_final.columns.get_loc('player')].to_list()

    return player_stats_final, jumps, drops

# Test cell for function above
player_stats_final = find_biggest_movers(final_df, 5)[0]
jumps = find_biggest_movers(final_df, 5)[1]
drops = find_biggest_movers(final_df, 5)[2]

print(jumps)
print(drops)
player_stats_final.head()

"""## Section 3 - Analytical & Visualization Tasks

In this section we will perform our analytical tasks and create the corresponding visualizations.

The first of these is an analysis of the growth of tournament purses during the 2015 - 2019 timeframe, and a display of those results in a polar histogram.
"""

# Create a polar histogam of purses over time

# Create purse analysis dataframes
purse_df = final_df.groupby(['tournament name','date_x', 'year', 'purse']).size().reset_index().rename(columns={0:'Player Count'}).sort_values('date_x', ascending = False)

purse_stats = purse_df.groupby('year', as_index=False).agg(Total=('purse','sum'),
                                            Min= ('purse','min'),
                                            Max= ('purse','max'),
                                            Average= ('purse','mean'),
                                            Count = ('purse', 'count')).set_index('year')

# Create a dictionary for colors to use for each year 2015 - 2019
colordict = {2015: '#30a2da', 2016:'#fc4f30', 2017: '#e5ae38', 2018: '#6d904f', 2019: '#8b8b8b'}

# Tweak the dataframe
df_polar = purse_df.reset_index()

# Define some (2) helper functions for the polar histogram
def draw_wedge(ax, start_angle, end_angle, length, bar_length, color):
    """
    This function draws a single bar in the polar histogram.

    Parameters:
    ax: Plot axis on which to render the wedge
    start_angle: Start angle of the wedge
    end_angle: End angle of the wedge
    length: Total length of the wedge
    bar_length: Causes partial wedge is to be drawn from inner radius length - width to outer radius length
    color: Fill color of the wedge

    Returns:
    This function does not return anything.
    """
    ax.add_artist(
        Wedge((0, 0),
            length, start_angle, end_angle,
            color=color, width=bar_length
        )
    )

def draw_reference_line(ax, point, size, padding, fontsize=18):
    """
    This function draws the lines around the polar histogram.

    Parameters:
    ax: Plot axis on which to draw the line
    point: The value at which to draw the line
    size: Thickness of the line
    padding: The size of the hole in the middle of the polar histogram
    fontsize: Font size of the label

    Returns:
    This function does not return anything.
    """
    draw_wedge(ax, 0, 360, point+padding+size/2, size, background_color)
    ax.text(-0.6, padding + point, '$' + str(point) +'M', va='bottom', rotation=1, fontsize=fontsize, weight='bold')


#Setup some basics for the polar histogam
background_color = '#FFFFFF'
START_ANGLE = 0 # At what angle to start drawing the first wedge
END_ANGLE = 340 # At what angle to finish drawing the last wedge
SIZE = (END_ANGLE - START_ANGLE) / len(df_polar) # The size of each wedge
PAD = 0.2 * SIZE # The padding between wedges
INNER_PADDING = 2 * df_polar.purse.min()
LIMIT = (INNER_PADDING + df_polar.purse.max()) * 1.3 # Limit of the axes

# Create the plot
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(18, 18))
ax.set(xlim=(-LIMIT, LIMIT), ylim=(-LIMIT, LIMIT))

#Iterate through each tournament and draw the wedge
for i, row in df_polar.iterrows():
    bar_length = row.purse
    length = bar_length + INNER_PADDING
    start = 100 + i*SIZE + PAD
    end = 100 + (i+1)*SIZE
    angle = (end + start) / 2

    #Draw the wedge
    draw_wedge(ax, start, end, length, bar_length, colordict[row.year])


# Add 'grid' lines, title, and annotations
grid_lines = [2, 4, 6, 8, 10, 12]
for line in grid_lines:
    draw_reference_line(ax, line, 0.06, INNER_PADDING)

plt.title('PGA Purses\n2015 - 2019', x=0.5, y=0.5, va="center", ha="center", fontsize=32, linespacing=1.5, weight='bold')
plt.text(14, 14, '2015 Purse Total:\n$' + str(purse_stats.loc[2015, 'Total']) + 'M', fontsize = 22, ha = 'center', weight='bold')
plt.text(20, -5, '2016 Purse Total:\n$' + str(purse_stats.loc[2016, 'Total']) + 'M', fontsize = 22, ha = 'center', weight='bold')
plt.text(7, -19, '2017 Purse Total:\n$' + str(purse_stats.loc[2017, 'Total']) + 'M', fontsize = 22, ha = 'center', weight='bold')
plt.text(-19, -8, '2018 Purse Total:\n$' + str(purse_stats.loc[2018, 'Total']) + 'M', fontsize = 22, ha = 'center', weight='bold')
plt.text(-14, 14, '2019 Purse Total:\n$' + str(purse_stats.loc[2019, 'Total']) + 'M', fontsize = 22, ha = 'center', weight='bold')

# Show the plot
plt.axis("off")
fig.set_facecolor('#076652')  # Set background color
plt.tight_layout()
plt.show()

"""In the first analysis of player performance, we wanted to visualize the OWGR for the top 5 players during the period 2015 - 2019, using a line chart."""

# Create a line chart of the OWGR ranking for the top 5 players

# Establish the beginning and end dates for the plot
left = final_df['date_x'].min()
right = final_df['date_x'].max()

# Initialize the plot
fig, ax = plt.subplots(figsize=(10, 5))
lines = []
labels = []

# Step through each of the top 5 players
for player in jumps:
    # Filter final_df for a specific player
    filtered_df = final_df[final_df['player'] == player].filter(['player', 'date_x', 'owgr'], axis=1)

    # Plot player OWGR over time
    line, = ax.plot(filtered_df['date_x'], filtered_df['owgr'], linewidth=3, label=player)

    # Store line object and label
    lines.append(line)
    labels.append(player)

# Format the x-axis to show year-month only
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))

# Set tick & plot area params
ax.tick_params(colors='white')
ax.grid(axis='y')
ax.grid(axis='x')

# Set axis labels & title
ax.set_xlabel('Year', weight='bold', color='white')
ax.set_ylabel('World Golf Ranking', weight='bold', color='white')
ax.set_title('Top 5 Player OWGR - 2015-2019', weight='bold', color='white')

# Complete the plot
plt.legend(lines, labels, loc = 'best', labelcolor='black')
plt.ylim(310, -10)
plt.xlim(left, right)
fig.set_facecolor('#076652')  # Set background color
plt.show()

"""Next, we wanted to analyze the degree to which players participated in PGA tour events. While there are more than 40 PGA tour events in a given season, players do not participate in all tour events. A boxplot seemed like an appropriate way to visualize this. As this analysis was used to establish the cutoff participation threshold ultimately used in the data cleaning phase, we utilized the pre-filtered dataset (df_main), which was inclusive of players who had participated in fewer than 10 tournaments and those that never appeared in the OWGR top 300 dataset.

The resulting boxplot shows the median participation for all players ranged from 16 tournaments in 2015, down to 12 tournaments in 2019. The boxplot also shows the distribution (Q1 to Q3), and minimum / maximum number of tournaments in which players participated 2015 through 2019.
"""

# Creat a box plot to characterize player participation by year
fig, ax = plt.subplots(figsize=(10, 5))
fig.set_facecolor('#076652')  # Set background color

# Group by player and year, count total tournaments played
tournaments_per_player_per_year = df_main.groupby(['player', 'year']).size().unstack()

# Create the boxplot with green background and formatted properties
boxprops = dict(facecolor='green', linewidth=1.5)
medianprops = dict(color='black', linewidth=2)
whiskerprops = dict(linewidth=1.5)
capprops = dict(linewidth=1.5)

tournaments_per_player_per_year.boxplot(
    patch_artist=True,
    boxprops=boxprops,
    medianprops=medianprops,
    whiskerprops=whiskerprops,
    capprops=capprops,
    ax=ax
)

ax.set_xlabel("Year", fontsize=12, color='white', weight = 'bold')
ax.set_ylabel("Total Tournaments Played", fontsize=12, color='white', weight = 'bold')
ax.set_title("Boxplot of Tournaments Played per Player (Per Year)", fontsize=14, color='white', weight = 'bold')

# Remove gridlines
ax.grid(False)

# Change tick color to white for visibility
ax.tick_params(axis='x', colors='white')
ax.tick_params(axis='y', colors='white')

# Set subplot background color
ax.set_facecolor('white')

plt.show()

"""Next, we wanted to see how top players (as defined by having the greatest improvement in OWGR) fared against the field in terms of the proportion of top 5 finishes, proportion of top 10 finishes, and proportion of cuts made.

We used a bar chart to display for this visualization, and found only 2 of the 5 players identified as ‘top’ players (Patrick Cantlay and Bryson Dechambeau) appeared among any of the top finishes / cuts analyses.
"""

# Create a bar chart for percentage top 5 finishes, percentage top 10 finishes, and percentage cuts made
final_df['finish'] = pd.to_numeric(final_df['finish'], errors='coerce')
total_tournaments = final_df.groupby('player').size()

# Calculate percentages
pct_top_5 = ((final_df[final_df['finish'] <= 5].groupby('player').size() / total_tournaments) * 100).sort_values(ascending=False)
pct_top_10 = ((final_df[final_df['finish'] <= 10].groupby('player').size() / total_tournaments) * 100).sort_values(ascending=False)
pct_made_cuts = ((final_df[final_df['made_cut'] == 1].groupby('player').size() / total_tournaments) * 100).sort_values(ascending=False)

# Create a figure with 3 subplots side by side
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Top 5 Percentage
pct_top_5.head(10).plot(kind='bar', color='blue', alpha=0.7, ax=axes[0])
axes[0].set_title("Top 10 Players - % of Top 5 Finishes",  weight='bold')
axes[0].set_xlabel("Player",  weight='bold').set_color('white')
axes[0].set_ylabel("Percentage of Top 5 Finishes (%)",  weight='bold').set_color('white')
axes[0].tick_params(axis='x', rotation=45)
axes[0].grid(axis='y')
axes[0].tick_params(axis='x', colors='white')
axes[0].tick_params(axis='y', colors='white')


# Top 10 Percentage
pct_top_10.head(10).plot(kind='bar', color='green', alpha=0.7, ax=axes[1])
axes[1].set_title("Top 10 Players - % of Top 10 Finishes",  weight='bold').set_color('white')
axes[1].set_xlabel("Player", weight = 'bold').set_color('white')
axes[1].set_ylabel("Percentage of Top 10 Finishes (%)", weight = 'bold').set_color('white')
axes[1].tick_params(axis='x', rotation=45)
axes[1].grid(axis='y')
axes[1].tick_params(axis='x', colors='white')
axes[1].tick_params(axis='y', colors='white')


# Cuts Made Percentage
pct_made_cuts.head(10).plot(kind='bar', color='red', alpha=0.7, ax=axes[2])
axes[2].set_title("Top 10 Players - % of Cuts Made",  weight='bold').set_color('white')
axes[2].set_xlabel("Player", weight = 'bold').set_color('white')
axes[2].set_ylabel("Percentage of Cuts Made (%)", weight = 'bold').set_color('white')
axes[2].tick_params(axis='x', rotation=45)
axes[2].grid(axis='y')
axes[2].tick_params(axis='x', colors='white')
axes[2].tick_params(axis='y', colors='white')

fig.set_facecolor('#076652')  # Set background color
plt.tight_layout()
plt.show()

"""Next, a bar chart was created to display the distribution of strokes gained by world rank buckets. This visualization shows that top 50 players separate themselves with consistently higher strokes gained, mainly by approach and off-the-tee performance. Beyond the top 50, strokes gained values stabilize, indicating similar skill levels from ranking 51-300. The biggest takeaway is the superior approach and off-the-tee games of the top 50 players. This reinforces the idea that elite players gain their edge through superior ball-striking rather than short-term fluctuations in putting performance. Additionally, putting contributes to total strokes gained but is more variable week to week, while approach and off-the-tee play provide a more stable foundation for success."""

# Create a function to display a stacked histogram of average strokes gained stats for all OWGR buckets
def plot_stacked_sg_histograms(final_df):
    """Creates stacked histograms where sg_total is built from sg_putt, sg_arg, sg_app, sg_ott."""

    # Remove placeholder OWGR values (301) before binning
    valid_data = final_df[final_df['owgr'] < 301].copy()

    # Define strokes gained categories & colors
    sg_components = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott']
    sg_total = 'sg_total'
    sg_colors = ['blue', 'green', 'orange', 'red']

    # Group by rank bucket and calculate cumulative average strokes gained
    bucket_stats = valid_data.groupby('rank_bucket')[sg_components + [sg_total]].mean().reset_index()

    # Set up subplot
    fig, ax_total = plt.subplots(figsize=(14, 6))

    # Plot SG Total as a stacked bar from its components
    bottom = np.zeros(len(bucket_stats))  # Initialize bottom stacking
    for i, col in enumerate(sg_components):
        ax_total.bar(bucket_stats['rank_bucket'], bucket_stats[col], width=8,
                     color=sg_colors[i], alpha=0.8, label=col.replace('_', ' ').title(), bottom=bottom)
        bottom += bucket_stats[col].values  # Stack the next component on top

    ax_total.set_ylabel("Sg Total (Stacked)", fontsize=12, color = 'white', weight = 'bold')
    ax_total.grid(True, linestyle="--", alpha=0.3)
    ax_total.set_ylim([-1.5, 1.5])
    ax_total.legend(loc='upper right', fontsize=10, labelcolor='black')



    # Shared x-axis settings
    ax_total.set_xlabel("World Rank Buckets (Grouped by 10)", fontsize=12, color = 'white', weight = 'bold')
    ax_total.set_xticks(np.arange(0, 300, 10))
    ax_total.set_xticklabels(np.arange(0, 300, 10), rotation=45)

    # Add title
    plt.title("Stacked Strokes Gained Breakdown by World Rank Bucket", fontsize=14, color = 'white', weight = 'bold')
    plt.tick_params(colors='white')
    fig.set_facecolor('#076652')  # Set background color
    plt.tight_layout()
    plt.show()

# Run the function with stacked sg_total
plot_stacked_sg_histograms(final_df)

"""To further explore this, a line chart was created to display the average finishing score to par by world rank buckets. Indeed, strokes to par seems to follow a similar trend; elite players score significantly lower, while the rest of the field remains relatively even. Note that finishing score is the end score regardless of if a player made the cut. This suggests that while the top-ranked players maintain consistent dominance, the gap between mid-tier and lower-ranked players remains relatively small."""

# Create a function to display a line chart of average strokes to par for all by OWGR buckets
def strokes_to_par(year_list, df):
    """
    This function creates a plot of average strokes to par .

    Parameters:
    year_list: The list of years being analyzed
    df: The dataframe containing strokes to par for each player / tournament combination

    Returns:
    This function does not return anything.
    """
    copy_final = df.copy()
    copy_final = copy_final[copy_final['year'].isin(year_list)]

    grouped_stp_year = copy_final.groupby(['year', 'rank_bucket'])['strokes_to_par'].mean().reset_index()

    fig, ax = plt.subplots(figsize=(12, 6))

    for year in grouped_stp_year['year'].unique():
        year_data = grouped_stp_year[grouped_stp_year['year'] == year]

        ax.plot(year_data['rank_bucket'], year_data['strokes_to_par'], linestyle='-', label=year)

        ax.set_xlabel("World Rank Buckets (Grouped by 10)", fontsize=12, color = 'white', weight = 'bold')
        ax.set_xticks(np.arange(0, 310, 10))
        ax.set_xticklabels(np.arange(0, 310, 10), rotation=45)

        ax.grid(axis='y')
        ax.grid(axis='x')

        ax.set_ylabel("Average Strokes to Par", color = 'white', weight = 'bold')

        ax.set_title('Average Strokes to Par by World Rank Bucket', color = 'white', weight = 'bold')
        plt.legend(loc='lower right', labelcolor='black')
        plt.tick_params(colors='white')
        fig.set_facecolor('#076652')  # Set background color

    plt.show()

# Run the function
strokes_to_par(final_df['year'].unique(), final_df)

"""Next, radar plots were created to compare strokes gained stats between the top 5 and bottom 5 players as measured by increases / decreases in OWGR.

These radar plots show how strokes gained stats have changed for both of these player groups. A Strokes Gained statistic > 0 means that a player did better than the rest of the tournament field, while a Strokes Gained statistic < 0 means the player did worse.
"""

# Create a function to create radar plots of all 6 strokes gained stats for the top 5 and bottom 5 players
def radar_plot(df):
    """
    This function draws 2 radar plots showing the 6 strokes gained stats for the top 5 and bottom 5 players
    in each of the years in the source dataframe.

    Parameters:
    df: The dataframe containing the 6 strokes gained stats

    Returns:
    This function does not return anything.
    """

    features = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott', 'sg_t2g', 'sg_total']

    radar_top = df[df['player'].isin(jumps)].groupby('year')[features].mean().dropna().reset_index()
    radar_bottom = df[df['player'].isin(drops)].groupby('year')[features].mean().dropna().reset_index()

    df_list = [radar_top, radar_bottom]

    table_min = radar_top.iloc[:, 1:].values.min()
    table_max = radar_top.iloc[:, 1:].values.max()

    titles = ['Top 5 Players Strokes Gained', 'Bottom 5 Players Strokes Gained']

    for t, df in enumerate(df_list):
        categories = df.columns[1:]
        num_vars = len(categories)
        angles = np.linspace(0, 2 * np.pi, num_vars, endpoint=False).tolist()
        angles += angles[:1]
        fig, ax = plt.subplots(figsize=(7, 7), subplot_kw=dict(polar=True))

        for i, row in df.iterrows():
            values = row[1:].tolist()
            values += values[:1]
            ax.plot(angles, values, label=row['year'], linewidth=2)
            ax.fill(angles, values, alpha=0.1)
            ax.set_ylim([table_min, table_max])

        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(categories, color='white', fontsize=10)
        ax.xaxis.set_tick_params(pad=10)
        ax.set_title(titles[t], fontsize=14, fontweight='bold')

        legend = plt.legend(loc='upper right', bbox_to_anchor=(1.1, 1.1))
        for text in legend.get_texts():
            text.set_text(text.get_text().split(".")[0])
            text.set_color("black")
        fig.set_facecolor('#076652')  # Set background color
        plt.show()

# Run the function
radar_plot(final_df)

"""Finally, a SPLOM was created to show the correlation between the 4 base strokes gained stats.

The diagonal shows the distribution of values for each individual strokes gained statistic. We can easily see that all of the strokes gained statistics are normally distributed around 0 with relatively small tails. This is the expected behavior because all of these statistics are relative meaning that as some players increase their strokes gained relative to the field, others who might not be playing as well will see their strokes gained stats decrease.
"""

# Create a function to display a SPLOM to visualize the correlation between strokes gained statistics
def plot_splom(df):
    """
    This function creates a SPLOM to visualize the correlation between the 4 base strokes gained statistics.

    Parameters:
    df: The dataframe containing the 4 base strokes gained stats

    Returns:
    This function does not return anything; it just displays the SPLOM.
    """

    # Remove placeholder OWGR values (301) before binning
    valid_data = df[df['owgr'] < 301].copy()

    # Select strokes gained stats for analysis
    sg_columns = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott']

    # Set up the Seaborn Pairplot (SPLOM)
    plt.figure(figsize=(12, 12))
    splom = sns.pairplot(
        valid_data,
        vars=sg_columns,  # Use only strokes gained columns
        hue="rank_bucket",  # Color-code by world rank bucket
        palette="viridis",  # Use a color scale that works well for ranking
        plot_kws={'alpha': 0.5, 's': 20},  # Transparency & smaller scatter points
        diag_kind="kde"  # Show distributions on diagonal
    )

    for ax in splom.axes.flatten():
        if ax is not None:
            plt.setp(ax.get_xticklabels(), color='white')
            plt.setp(ax.get_yticklabels(), color='white')
            ax.xaxis.label.set_color('white')
            ax.yaxis.label.set_color('white')
            ax.tick_params(axis='x', colors='white')
            ax.tick_params(axis='y', colors='white')
        plt.suptitle("Scatterplot Matrix of Strokes Gained Statistics", fontsize=14, y=1.02, fontweight='bold')

    plt.show()


# Set the background color & run the function
plt.rcParams['figure.facecolor'] = '#076652' # Set the background color to Masters green
plot_splom(final_df)

"""## Section 4 - Supplemental Work

This section includes additional data exploration and visualizations created for this project, but ultimately excluded from the final report.
"""

# Create a bar chart for counts of top 5 finishes, top 10 finishes, and cuts made
final_df['finish'] = pd.to_numeric(final_df['finish'], errors='coerce')

# Calculate top 5 finishes
top_5_finishes = final_df[final_df['finish'] <= 5].groupby('player').size().sort_values(ascending=False)

# Calculate top 10 finishes
top_10_finishes = final_df[final_df['finish'] <= 10].groupby('player').size().sort_values(ascending=False)

# Calculate most made cuts (assuming 'made_cut' is a binary column: 1 = made cut, 0 = missed cut)
made_cuts = final_df[final_df['made_cut'] == 1].groupby('player').size().sort_values(ascending=False)

# Create a figure with 3 subplots side by side
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Top 5 Finishes
top_5_finishes.head(10).plot(kind='bar', color='blue', alpha=0.7, ax=axes[0])
axes[0].set_title("Top 10 Players with Most Top 5 Finishes")
axes[0].set_xlabel("Player")
axes[0].set_ylabel("Top 5 Finishes")
axes[0].tick_params(axis='x', rotation=90)
axes[0].grid(axis='y')

# Top 10 Finishes
top_10_finishes.head(10).plot(kind='bar', color='green', alpha=0.7, ax=axes[1])
axes[1].set_title("Top 10 Players with Most Top 10 Finishes")
axes[1].set_xlabel("Player")
axes[1].set_ylabel("Top 10 Finishes")
axes[1].tick_params(axis='x', rotation=90)
axes[1].grid(axis='y')

# Most Made Cuts
made_cuts.head(10).plot(kind='bar', color='red', alpha=0.7, ax=axes[2])
axes[2].set_title("Top 10 Players with Most Made Cuts")
axes[2].set_xlabel("Player")
axes[2].set_ylabel("Made Cuts")
axes[2].tick_params(axis='x', rotation=90)
axes[2].grid(axis='y')

plt.tight_layout()
plt.show()

# Displays a player's World Ranking over time as well as a 10 week rolling average of their stokes gained stats -- Ben
# Allows for comparison of multiple directly with constant y-scale 0-301 for WR and -3 to 4 for strokes gained
## DECIDED NOT TO USE IN PRESENTATION

# Can flip back, have world rank in positive direction

def plot_single_player(player_name, smooth=True, window=10):

    # Filter data for the selected player
    player_data = final_df[final_df['player'] == player_name].copy()

    # Ensure dates are in datetime format
    player_data['date_x'] = pd.to_datetime(player_data['date_x'])

    # Sort data by date
    player_data = player_data.sort_values(by='date_x')

    # Define strokes gained categories & colors
    sg_columns = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott', 'sg_t2g', 'sg_total']
    sg_colors = {
        'sg_putt': 'blue',
        'sg_arg': 'green',
        'sg_app': 'orange',
        'sg_ott': 'red',
        'sg_t2g': 'cyan',
        'sg_total': 'black'
    }

    # Apply rolling mean smoothing & linear interpolation if enabled
    if smooth:
        for col in sg_columns:
            player_data[col] = player_data[col].rolling(window=window, min_periods=1).mean()
            player_data[col] = player_data[col].interpolate(method='linear')

    # Create figure
    fig, ax1 = plt.subplots(figsize=(12, 6))

    # Primary Y-Axis: World Rank (Purple)
    ax1.plot(player_data['date_x'], player_data['owgr'], label="World Rank", color='purple', linestyle='-', linewidth=2)
    ax1.set_ylabel("World Rank (Lower is Better)", color='purple')
    ax1.set_ylim([0, 305])  # Fixed OWGR scale
    ax1.tick_params(axis='y', labelcolor='purple')

    # Secondary Y-Axis: Strokes Gained
    ax2 = ax1.twinx()
    for col in sg_columns:
        ax2.plot(player_data['date_x'], player_data[col], label=col.replace('_', ' ').title(),
                 color=sg_colors[col], linestyle='-', linewidth=1)

    ax2.set_ylabel("Strokes Gained", color='black')
    ax2.set_ylim([-3, 4]) # Strokes Gained scale (-3 to 4)
    ax2.tick_params(axis='y', labelcolor='black')

    # Add Titles & Labels
    plt.title(f"{player_name} - World Rank vs. Strokes Gained Over Time")
    ax1.set_xlabel("Date")
    fig.autofmt_xdate()  # Rotate date labels

    # Legends & Adjustments
    ax1.legend(loc='upper left', frameon=True)
    ax2.legend(loc='center left', bbox_to_anchor=(1.05, 0.5), frameon=False, fontsize=10)  # Move legend outside

    plt.grid(True, linestyle="--", alpha=0.2)  # Lighter grid for better readability
    plt.show()

# Example usage
plot_single_player('JON RAHM', smooth=True, window=10)
plot_single_player('KEEGAN BRADLEY', smooth=True, window=10)
plot_single_player('RICKIE FOWLER', smooth=True, window=10)
plot_single_player('DANNY WILLETT', smooth=True, window=10)
plot_single_player('FRANCESCO MOLINARI', smooth=True, window=10)

# Chart (bucketed by 10) of world golf rank and average strokes gained stats for respective bucket -- Ben
def plot_separate_sg_histograms(final_df):
    """Creates separate histograms for each strokes gained category by world rank bucket, keeping a constant scale."""

    # Remove placeholder OWGR values (301) before binning
    valid_data = final_df[final_df['owgr'] < 301].copy()

    # Define strokes gained categories & colors
    sg_columns = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott', 'sg_t2g', 'sg_total']
    sg_colors = ['blue', 'green', 'orange', 'red', 'gray', 'purple']

    # Group by rank bucket and calculate cumulative average strokes gained
    bucket_stats = valid_data.groupby('rank_bucket')[sg_columns].mean().reset_index()

    # Set up multiple subplots (Increased height)
    fig, axes = plt.subplots(nrows=len(sg_columns), ncols=1, figsize=(14, 14), sharex=True)

    # Loop through each strokes gained category and plot separately
    for i, col in enumerate(sg_columns):
        ax = axes[i]
        ax.bar(bucket_stats['rank_bucket'], bucket_stats[col], width=8, color=sg_colors[i], alpha=0.8)
        ax.set_ylabel(col.replace('_', ' ').title(), fontsize=12)
        ax.grid(True, linestyle="--", alpha=0.3)

        # Keep y-axis scale constant across all subplots
        ax.set_ylim([-1.5, 1.5])  # Ensures all charts are comparable

    # Shared x-axis settings
    axes[-1].set_xlabel("World Rank Buckets (Grouped by 10)", fontsize=12)
    axes[-1].set_xticks(np.arange(0, 310, 10))
    axes[-1].set_xticklabels(np.arange(0, 310, 10), rotation=45)

    plt.suptitle("Average Strokes Gained by World Rank Bucket (Separated Histograms, Constant Scale)", fontsize=14)
    plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust layout to fit title
    plt.show()

plot_separate_sg_histograms(final_df)

# Function to create line graphs for "player score" by year -- I think we should look at the average "player score" by OWGR over the years rather than looking at single players.
# The visualization doesn't really work well the way it's currently built

def player_score_bucket(player_name_list, df):
  stats = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott', 'sg_t2g', 'sg_total']

  stats_grouped_df = df.groupby('year')[stats].quantile(0.75).reset_index().rename(columns=
                                  {'sg_putt':'sg_putt_t20',
                                   'sg_arg':'sg_arg_t20',
                                   'sg_app':'sg_app_t20',
                                   'sg_ott':'sg_ott_t20',
                                   'sg_t2g':'sg_t2g_t20',
                                   'sg_total':'sg_total_t20'})

  player_grouped_df = df.groupby(['player', 'year'])[stats].mean().reset_index()

  merged_player_stats = player_grouped_df.merge(stats_grouped_df, on='year', how='inner')

  column_titles = ['sg_putt', 'sg_arg', 'sg_app', 'sg_ott', 'sg_t2g', 'sg_total']
  column_titles_t20 = ['sg_putt_t20', 'sg_arg_t20', 'sg_app_t20', 'sg_ott_t20', 'sg_t2g_t20', 'sg_total_t20']
  column_titles_binary = ['sg_putt_above_top_20', 'sg_arg_above_top_20', 'sg_app_above_top_20', 'sg_ott_above_top_20', 'sg_t2g_above_top_20', 'sg_total_above_top_20']

  for col in column_titles:
    merged_player_stats[f'{col}_above_top_20'] = (merged_player_stats[col] > merged_player_stats[f'{col}_t20']).astype(int)

  merged_player_stats['num_points_above_top_20'] = merged_player_stats[column_titles_binary].sum(axis=1)

  plt.figure(figsize=(12, 6))

  for player in player_name_list:
    player_df = merged_player_stats.loc[merged_player_stats['player'] == player].sort_values(by='year', ascending=True)
    plt.plot(player_df['year'], player_df['num_points_above_top_20'], label=player)

  plt.xlabel('Year')
  plt.ylabel('Number of Stats Inside Top 25%')
  plt.title('Number of Stats Inside Top 25% by Year')
  plt.xticks(range(2015, 2020))
  plt.yticks(range(0, 5))
  plt.legend()
  plt.show()

player_score_bucket(jumps, final_df)